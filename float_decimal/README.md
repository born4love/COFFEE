
#### 问题: echo floor(19.9 * 100) = 189

起初遇到这个问题的时候，总觉得是PHP内核的问题，后来使用 python 和 C 语言测试过，原来都有问题，问题抽象为：

>当对一个浮点数执行计算或者类型转换时，会出现精度丢失的可能性。

为什么是可能性呢，因为这个不是必然的，比如

```php

echo floor(1.25 * 100); // 输出： 125

echo intval(19.9 * 100);  // 输出 1989

var_dump (0.1 + 0.2 == 0.3) // 输出 bool(false)

```

#### 从机器角度看问题

为了弄清楚这个问题，我们首先来看一下计算机怎么存储浮点数

一个8位的二进制空间（一个字节）可以表示从0到255的数字，但是这只能表示整数，不包括实数（小数 如：0.5,20.456等）

![二进制表示的数字181](https://github.com/deanisty/notes/blob/master/float_decimal/binary-floating-point-binary-byte.png)
二进制表示的数字181

为了使用二进制形式表示小数，需要更多的二进制位还要给这些二进制位定义良好的格式。这在计算机里被称作 “浮点型”。然而，浮点型只是尽最大的可能去接近
某个10进制的小数，但是无法完全等于这个小数的值。比如一个很特殊的小数 PI ： 3.14159265… ，也就是圆周率，它是一个无穷的小数，如果表示成二进制就
需要无数个二进制位。一个二进制的浮点型数字只是一个在精度和范围之间的折中，具体的长度取决于使用方式。

“浮点型”的称呼可以理解成小数点是可以移动的，就像10进制的小数表示成科学计数法可以是 523.0 * 10^0 或者  52.30 * 10^1 或者  52.30 * 10^2 ....，
小数点向左移动会增加指数的值，向右移动则会减小指数的值。在计算机中，二进制的浮点型的小数点的移动和10进制是类似的，只不过指数的底是 2 而不是 10。

IEEE 754 标准 （Institute of Electrical and Electronics Engineers）定义了2个最常用的浮点数存储格式：

* 短实数：32bit (单精度) 1 位符号位(S)，8 位指数值(E)，23 位精度值(M)
* 长实数：64bit (双精度) 1 位符号位(S)，11 位指数值(E)，52 位精度值(M)

![32位浮点型二进制格式](https://github.com/deanisty/notes/blob/master/float_decimal/binary-floating-point-binary-short-real-32-bit.png)
32位浮点型二进制格式：二进制的位置（灰色）和二进制位（都设置为1）

参照上图：以10进制数 + 34.890625 * 10^4 为例，这是一个正数所以符号位为 S=+ ,精度值为 M=34.890625，指数值为 E=4，因为是10进制，所以 base=10。

IEEE 754 关于浮点数二进制位的规则定义：

* 符号位(S): 只占一位，表示浮点数的正负值属性，S=1 表示负值，S=0 表示正数。
* 精度位(M): 23 位（32位单精度浮点数） 可以表示 8388608 个不同的值。
* 指数位(E): 8 位 （32位单精度浮点数）可以表示 256个不同的值。而且因为指数值有正负之分，所以把这 8 位值分成两部分，（0-127）表示 -127 ~ -1 ，（128-255）表示 0 ~ 127。所以真实的指数值需要用 E 的值减去127。如图：一个正值的指数 10^5 的 E 值存储在二进制位里其实是：5+127=132，一个负值的指数 10^(-8) 的 E 值存储在二进制位里其实是：-8+127=119.

![8位二进制的取值范围](https://github.com/deanisty/notes/blob/master/float_decimal/binary-floating-point-8-bit-range.png)8位二进制的正负值范围

#### 十进制浮点数转二进制的转换步骤

一个浮点数包含整数部分 和 小数部分，假设一个浮点数的十进制形式是 34.890625 ，整数部分是 34，小数部分是 .890625，转换步骤如下：

* 把十进制数转成二进制的科学计数法，整数部分和小数部分独立处理 如： 100010.111001 * 2^0 (34 = 100010 and .890625 = 111001)
* 再把科学计数法的二进制值格式化成规范格式（小数点位于最高位的1的右边，同时调整指数值）如：1.00010111001*25
* 指数值 +127 并转成二进制格式
* 把精度值的最高位的1舍去，符号位+指数位+精度值 最终组成了浮点数的二进制表示 如：  0 10000100 0001011100100000000000

以 34.890625（10进制）为例说明4个步骤

第一步：

把整数部分也就是 34 除 2 ，如果整除记为 0，如果不能整除记为 1，商的整数部分继续除 2，能整除记为 0，不能整除记为2，重复执行直到商为0，最后所有二进制位倒序排列就是34的二进制表示 ： 10 0010

| 除2    | 商  | 剩余整数 | 结果 |
|--------|-----|----------|------|
| 34/2   | 17  | 17       | 0    |
| 17/2   | 8.5 | 8        | 1    |
| 8/2    | 4   | 4        | 0    |
| 4/2    | 2   | 2        | 0    |
| 2/2    | 1   | 1        | 0    |
| 1/2    | 0.5 | 0        | 1    |


把小数部分 0.890625 乘以 2，如果结果 >= 1，记为 1，否则为0，乘积的小数部分再乘以 2 如果 >= 1 记为1，否则记为 0 ，重复操作直至乘积为 1，然后将所有的二进制位顺序排列即为小数部分的 二进制表示。这里有一个问题：在 32Bit 的浮点数表示法中，精度值 M 的长度是 23 ，如果最后耗尽了 23 个二进制位也不能得到1，那这个浮点数的精度值就损失掉了，只能使用 23 个二进制位表示它的小数部分，这就是导致了本文开始的那些例子里奇怪的结果的根本原因，有些数在计算机里根本无法被毫无损失的存储。而 0.890625 这个值正好可以：  111001

| 乘2         | 积      | 剩余小数 | 结果 |
|-------------|---------|----------|------|
| .890625 * 2 | 1.78125 | .78125   | 1    |
| .78125 * 2  | 1.5625  | .5625    | 1    |
| .5625 * 2   | 1.125   | .125     | 1    |
| .125 * 2    | 0.25    | .25      | 0    |
| .25 * 2     | 0.5     | .5       | 0    |
| .5 * 2      | 1       | 0        | 1    |

第二步：

将得到的二进制科学计数值标准化，也就是把 100010.111001 * 2^0 的小数点左移5位，指数值同时增加5，表示为 1.00010111001 * 2^5。

这一步里有一点需要注意，就是小数点左移的时候要保证小数点的最左边是第一个 1，也就是要保证最终的精度值 M 一定是 1 开头的。

第三步：

这上一步里的结果中得到指数值为 5 ，加上 127 得到 5 + 127 = 132,所以二进制的 E = 1000 0100 

第四步：

前三步的结果中得到的 S E M 的二进制值最终组成小数 34.890625 的二进制表示， M 的最高位的 1 舍去，只保存剩余的值，这样就可以省去一个二进制位，因为 M 的值始终是 1 开头的，没有必要浪费一个二进制位，然后是小数点。

* S = 0 (正数) 
* E = 1000 0100 (132)
* M = 00010111001 (舍去小数点前面的 1)

组合成浮点值就是 ：  0 10000100 0001011100100000000000

![转成浮点值的结果](https://github.com/deanisty/notes/blob/master/float_decimal/binary-floating-point-decimal-to-binary-result.png)
转换成二进制的浮点值

注：精度值 M 需要 “左对齐”，右侧补 0 ， 指数值 E 需要 “右对齐” ，左侧补 0


#### 二进制浮点数转回10进制值

上面得到的二进制浮点值是： 0 10000100 0001011100100000000000

按照转换规则中的定义： 在 32bit 的表示中，第一个二进制位表示符号，S= 0 表示正数，接下来 8 位表示指数值 E = 10000100，剩余23位表示精度值M = 0001011100100000000000。
E 的值转成10进制 ： 2^2 + 2^7 = 132,因为 E 的值是表示正负两部分的指数值，在存储前加了127，所以这里要减去 127,132-127 = 5. 所以10进制的指数值是5.
M 的值需要去除后补的0，并且最高位补1和小数点，得到 1.00010111001，所以最终要计算的结果表示为：M * 2^E * S = 1.00010111001 * 2^5,计算出10进制的结果可以使用  (2^0 + 2^-4 + 2^-6 + 2^-7 + 2^-8 + 2^-11) * 2^5 = 34.890625 或者 (1 + 1/16 + 1/64 + 1/128 + 1/256 + 1/2048) * 25 = 34.890625。

#### 证明示例

这个二进制浮点值最终被完整的转换成了10进制的 34.890625，也就是这个示例里最开始使用的那个十进制的数字。展示了如何在二进制的浮点数和10进制的小数之间做转换，在此过程中也找到了浮点数做运算产生误差的原因，但是为了证实本文开头的几个输出展示的问题，我们把例子里用到的10进制数转换成二进制表示，然后再转回10进制，看看是不是因为计算机的存储导致了精度的丢失。

为了避免每次转换都要手动计算，我们借助一个工具：[FloatConverter](https://www.h-schmidt.net/FloatConverter/IEEE754.html)，这个工具可以进行10进制的小数和二进制的浮点值的转换，并且能够精确展示计算机中实际存储的值，通过这个值我们可以看出来是否丢失了精度。


```php

echo floor(1.25 * 100); // 输出： 125

```
![1.25的二进制表示](https://github.com/deanisty/notes/blob/master/float_decimal/1.25.png)


```php

echo intval(19.9 * 100);  // 输出 1989

```

![19.9的二进制表示](https://github.com/deanisty/notes/blob/master/float_decimal/19.9.png)


```php

var_dump (0.1 + 0.2 == 0.3) // 输出 bool(false)

```

![0.1的二进制表示](https://github.com/deanisty/notes/blob/master/float_decimal/0.1.png)
![0.2的二进制表示](https://github.com/deanisty/notes/blob/master/float_decimal/0.2.png)


能够看出，1.25像我们例子中的 34.890625 一样，能够被完整的表示为二进制浮点数，所以计算不会丢失精度，而 19.9 却被表示为 19.8999996185302734375，
所以乘以100再执行 floor 就是 1989，损失了精度，而 0.1 和 0.2 在计算机表示法里却比实际的值要大 ，这也是二进制浮点数表示法决定的，因此 0.1 + 0.2 和
0.3 在计算机看来并不相等。

在PHP中，可以通过 ini_set 设置 'precision' 的值来调整浮点数输出的有效数的位数，可以打印出浮点数存储的准确数值. precision 的默认值是 14，PHP在处理浮点数的时候会对数字进行默认的四舍五入操作。

```PHP

ini_set("precision", 17);

echo 0.1;   // 0.10000000000000001
echo 19.9;  // 19.899999999999999
echo 0.3;  // 0.29999999999999999

ini_set("precision", 30);

echo 0.1;   // 0.10000000000000000555111512312578
echo 19.9;  // 19.8999999999999985789145284798
echo 0.3;  // 0.29999999999999998889776975374843
```




相关阅读

* 浮点数和二进制相互转换： https://blog.penjee.com/binary-numbers-floating-point-conversion/
* 浮点数二进制存储工具: https://www.h-schmidt.net/FloatConverter/IEEE754.html
* PHP文档浮点数解释： http://php.net/manual/zh/language.types.float.php
* PHP修改浮点数显示有效数的位数：http://php.net/manual/zh/ini.core.php#ini.precision
