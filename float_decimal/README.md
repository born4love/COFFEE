
#### 问题: echo floor(19.9 * 100) = 189

起初遇到这个问题的时候，总觉得是PHP内核的问题，后来使用 python 和 C 语言测试过，原来都有问题，问题抽象为：

>当对一个浮点数执行隐式/显示的数值类型转换时，会出现精度丢失的可能性。

为什么是可能性呢，因为这个不是必然的，比如

```php

echo floor(1.25 * 100); // 输出： 125

echo intval(19.9 * 100);  // 输出 1989

var_dump (0.1 + 0.2 == 0.3) // 输出 bool(false)

```

#### 从机器角度看问题

为了弄清楚这个问题，我们首先来看一下计算机怎么存储浮点数

一个8位的二进制空间（一个字节）可以表示从0到255的数字，但是这只能表示整数，不包括实数（小数 如：0.5,20.456等）

![二进制表示的数字181](https://github.com/deanisty/notes/blob/master/float_decimal/binary-floating-point-binary-byte.png)
二进制表示的数字181

为了使用二进制形式表示小数，需要更多的二进制位还要给这些二进制位定义良好的格式。这在计算机里被称作 “浮点型”。然而，浮点型只是尽最大的可能去接近
某个10进制的小数，但是无法完全等于这个小数的值。比如一个很特殊的小数 PI ： 3.14159265… ，也就是圆周率，它是一个无穷的小数，如果表示成二进制就
需要无数个二进制位。一个二进制的浮点型数字只是一个在精度和范围之间的折中，具体的长度取决于使用方式。

“浮点型”的称呼可以理解成小数点是可以移动的，就像10进制的小数表示成科学计数法可以是 523.0 * 10^0 或者  52.30 * 10^1 或者  52.30 * 10^2 ....，
小数点向左移动会增加指数的值，向右移动则会减小指数的值。在计算机中，二进制的浮点型的小数点的移动和10进制是类似的，只不过指数的底是 2 而不是 10。

IEEE 754 标准 （Institute of Electrical and Electronics Engineers）定义了2个最常用的浮点数存储格式：

* 短实数：32bit (单精度) 1 位符号位(S)，8 位指数值(E)，23 位精度值(M)
* 长实数：64bit (双精度) 1 位符号位(S)，11 位指数值(E)，52 位精度值(M)

![32位浮点型二进制格式](https://github.com/deanisty/notes/blob/master/float_decimal/binary-floating-point-binary-short-real-32-bit.png)
32位浮点型二进制格式：二进制的位置（灰色）和二进制位（都设置为1）

参照上图：以10进制数 + 34.890625 * 10^4 为例，这是一个正数所以符号位为 S=+ ,精度值为 M=34.890625，指数值为 E=4，因为是10进制，所以 base=10。

IEEE 754 关于浮点数二进制位的规则定义：

* 符号位(S): 只占一位，表示浮点数的正负值属性，S=1 表示负值，S=0 表示正数。
* 精度位(M): 23 位（32位单精度浮点数） 可以表示 8388608 个不同的值。
* 指数位(E): 8 位 （32位单精度浮点数）可以表示 256个不同的值。而且因为指数值有正负之分，所以把这 8 位值分成两部分，（0-127）表示 -127 ~ -1 ，（128-255）表示 0 ~ 127。所以真实的指数值需要用 E 的值减去127。如图：一个正值的指数 10^5 的 E 值存储在二进制位里其实是：5+127=132，一个负值的指数 10^(-8) 的 E 值存储在二进制位里其实是：-8+127=119.

![8位二进制的取值范围](https://github.com/deanisty/notes/blob/master/float_decimal/binary-floating-point-8-bit-range.png)















相关阅读

* 浮点数和二进制相互转换： https://blog.penjee.com/binary-numbers-floating-point-conversion/
* 浮点数二进制存储工具: https://www.h-schmidt.net/FloatConverter/IEEE754.html
* PHP文档浮点数解释： http://php.net/manual/zh/language.types.float.php
