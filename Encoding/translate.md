### 每一个开发者绝对必须至少需要了解unicode和字符集（没有例外）


### 回顾历史

  想弄明白字符集最好的方式就是按照年代的顺序去了解它的发展历程
  
  在半导体盛行的那个年代，那时候Unix被发明出来，K&R开发了C语言，所有的一切都很简单。对于那时的计算机和程序员来说，唯一有意义的字符集合就是英文字符，当时有一套编码规范叫ASCII，这个规范可以用32到127之间的数字表示所有的英文字符。32表示空格，65表示大写字母A。这套规则可以很方便的用7个二进制位来存储。此时大多数计算机都是使用8个二进制位作为一个字节，所以一个字节就足以保存所有的ASCII字符，并且还有一个完整的二进制位没有被用到。ASCII编码中数值小于32的被称为不可打印字符，他们主要是用来念咒语诅咒别人，可惜这是一个玩笑，他们真正的目的是作为控制字符，比如7代表的字符会使你的计算机发出beep的声音，12代表的控制字符会控制打印机换纸。
  
  对一个英语使用者来说，这一切都不会有什么问题。
  
  正是因为一个字节有8个二进制位，很多人开始想“嗯，我们可以使用128-255之间的字符来表达我们自己的编码”，问题是很多人在同一时间有了这个想法，但是如何填充128-255之间的空间他们的想法又不一样，最终产生了许许多多对这128个字符的使用方式，也就产生许多的不同的字符编码方式。后来IBM-PC设计出来一种名叫OEM的字符编码规范，为不同地区不同语言的计算机的128-255的空间分别制定了一套字符编码规则，而且这种规范还被收录到ANSI的标准中，在ANSI标准里，大家都对于低7位的使用都达成一致，就是和ASCII一样，但是有很多不同的方法来使用高128的空间，具体如何使用就取决于你在哪里居住，你使用什么语言。这些不同的标准就被称为 code pages(可能被翻译为 编码页，但是使用英文更容易理解)。比方说以色列的DOS操作系统使用862号code page，而希腊的用户使用737号code page。MS-DOS系统的不同国家语言的各个版本分别支持了不同 code page,用来处理从英文到冰岛语的各种语言，甚至还有支持“多语言”的code page，能同时在一台计算机上处理Esperanto（世界语） and Galician（加利西亚语），但是如果两种语言用互不兼容的方式使用最高位的128个空间，那就无法同时支持。
  
  与此同时，在亚洲，更加疯狂的事情有发生了，亚洲的文字多达上千个，8个二进制位根本放不下。然而一种叫DBCS（“double byte character set”）的复杂编码出现了，在这种编码里，有的字符占用一个字节，有的字符占用两个字节，这样一来，很容易在字符串中向前移动，但是向后移动变得不太可能，编程者被鼓励使用 Windows’ AnsiNext 和 AnsiPrev 两个方法来取代类似s++和s--的指针移动指令，因为这两个方法知道如何处理这种复杂的映射关系。
  
  但是，大部分人还是依旧把一个字节当做一个字符，认为一个字符占用8 bits，当然前提是你永远不会把字符串从一台计算机移动到另一台，并且你不会使用两种不同的语言，如果是这样的话，一切还可以正常运行。可是，伴随着互联网的出现，在计算机之间传输数据变成了家常便饭，这样本来乱糟糟的各种编码规范瞬间瓦解了。幸运的是，Unicode被发明了出来。
  
  
### Unicode

  Unicode 勇敢的尝试着创造了一个唯一的字符映射集合，包含了这个星球上所有的可以书写出来的字符，甚至也包含了一些杜撰出来的语言，比如 Klingon（克林贡语）。有些人误以为Unicode只不过是简单的16位编码，每个字符都占用16个二进制位，总共有2的16次方（65536）个字符。事实上，这并不正确。这只是一个对于Unicode的很常见的说法，如果你也这样认为，不要觉得悲伤。
  
  事实上，Unicode用一种不同的视角来看待字符，你必须要以Unicode的方式来看待问题，不然一切都没有意义。
  
  截止目前，我们假设一个字符可以映射成为二进制的一些数据位，你可以把这些bits存到内存或者硬盘里：
  
  ```C
  A -> 0100 0001
  ```
  在Unicode中，一个字符映射为一个被称之为 code point 的东西，但是这只是一个理论性的概念。这个code point如何在内存和硬盘里存储是另外一个完全不同的话题。在Unicode中，字符 A 只是一个概念（原文是：`the letter A is a platonic ideal. It’s just floating in heaven`），它和 B 不同，和 a 也不同， 但是它和Times New Roman字体的A一样，和Helvetica字体的A也一样，这似乎没有什么争议，但是在一些其他语言中，可以找到能引起争议的字符：德语中的ß是真表示一个字符还是两个 ss 的另外一种漂亮的书写方式？如果一个单词末尾的字符的书写形式改变了，它就变成了另外一个字符吗？犹太人说是的，阿拉伯人说并不会。不管怎样，Unicode组织中聪明人在距今大约25年前的时间（原文是10年前，文章著于2003年）已经把这个问题弄明白了，同时也伴随着大量的高度政治辩论。
  
  Unicode为所有语言的字母表中的每一个概念性的字符都被分配了一个魔法数字，写出来像这样：U+0639.这个魔法数字就是 code point。“U+”意味着这是Unicode，后面的数字是16进制（hexadecimal）。U+0639表示的是阿拉伯字符 Ain，英文里的 A 的Unicode 是 U+0041.你可以使用Windows系统中的 charmap 命令查找字符的Unicode映射，或者访问 [Unicode官方网站](http://www.unicode.org/)。
  
  Unicode能够定义多少个字符并没有真正意义上的限制，事实上早已超过了 65536 ，所以并不是每一个Unicode字符都可以被放置到两个字节里，所以那只是一个说法而已。
  
  好了，假设我们有下面这样一个字符串：
  ```C
    Hello
  ```
  根据这五个字符的Unicode转换成Unicode编码就是这样的：
  ```C
    U+0048 U+0065 U+006C U+006C U+006F
  ```
  只是一串code points，就是一串数字而已？我们还没有讨论如何在内存中存储这些Unicode编码或者如何在邮件信息中表示他们。


### Encoding

  这个时候字符编码出现了。
  最早时候对Unicode的编码的方式就是将Unicode字符存储在两个字节中，这种方式就导致了后来人们对Unicode字符占2个字节的误解。所以 Hello 就变成了：
  ```C
  00 48 00 65 00 6C 00 6C 00 6F
  ```
  但是，也可能是这样的：
  ```C
  48 00 65 00 6C 00 6C 00 6F 00 
  ```
  早期对Unicode编码的实现者希望可以将字符编码保存为high-endian 和 low-endian 两种模式，具体使用哪种取决于他们的CPU对哪种存储方式处理的更快速，所以就有了两种方式存储Unicode。为了实现两种字节序，又有一种怪异的惯例被发明出来，就是在文件的最开始存储两个多余的字节 FE FF（大端序） ，这个被称为 UBOM （Unicode Byte Order Mark），如果你把这两个前缀字节的顺序交换位置就变成了 FF FE （小端序），然后你的字符串就会被解码的人按照相反的字节序解析。一开始并不是所有的Unicode字符都有字节序的。
  
  在一段时间内Unicode看似很不错了，但是开发者开始抱怨了。他们说“看那些多余的0”，因为他们是美国人，他们使用英语，所以他们几乎用不到 U+00 ~ U+00FF 之外的 code point，因此有的人认为应该保留单字节的编码，有的人也并不介意增加一个字节的空间存储字符。而且更多人不想更改编码是因为已经有大量的文本是使用各种各样的 ANSI 和 DBCS字符集编码的，没人愿意重新把这些文件转换编码。就因为这个原因，大部分人决定忽略Unicode，这种情况持续了好几年，同时也使事情变得更糟糕。
  
  就这样，精妙的UTF-8编码思想被发明出来了。UTF-8是另外一种编码方式，使用8位的字节在内存中存储Unicode 的code points，也就是U+数字。值在0-127之间的code point使用一个字节存储，只有 > 128 的 code point 使用 2个，3个最大至6个字节存储。看图，[戳这里](https://i1.wp.com/www.joelonsoftware.com/wp-content/uploads/2003/10/utf8.png?resize=400%2C63&ssl=1)
  
  


>译至:
[The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/)
